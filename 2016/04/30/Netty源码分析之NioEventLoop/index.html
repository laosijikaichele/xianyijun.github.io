<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
  
  
  

  
    
    
  

  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  




<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Netty," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Netty源码分析之Eventloop
Netty线程模型Netty的线程模型可以根据不同的用户参数来选择不同的线程模型，Netty支持的线程模型有Reactor单线程模型、Reactor多线程模型和主从Reactor多线程模型。Reactor是处理并发IO的一种常见模式。他主要是通过将所有的要处理的IO事件都注册到中心IO多路复用器上，同时主线程阻塞在多路复用器上，当有IO时间到来的时候或者准备">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty源码分析之NioEventLoop">
<meta property="og:url" content="http://xianyijun.github.io/2016/04/30/Netty源码分析之NioEventLoop/index.html">
<meta property="og:site_name" content="枯叶未凋零">
<meta property="og:description" content="Netty源码分析之Eventloop
Netty线程模型Netty的线程模型可以根据不同的用户参数来选择不同的线程模型，Netty支持的线程模型有Reactor单线程模型、Reactor多线程模型和主从Reactor多线程模型。Reactor是处理并发IO的一种常见模式。他主要是通过将所有的要处理的IO事件都注册到中心IO多路复用器上，同时主线程阻塞在多路复用器上，当有IO时间到来的时候或者准备">
<meta property="og:image" content="http://7xrl91.com1.z0.glb.clouddn.com/Eventloop.png">
<meta property="og:updated_time" content="2016-05-01T12:12:01.778Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Netty源码分析之NioEventLoop">
<meta name="twitter:description" content="Netty源码分析之Eventloop
Netty线程模型Netty的线程模型可以根据不同的用户参数来选择不同的线程模型，Netty支持的线程模型有Reactor单线程模型、Reactor多线程模型和主从Reactor多线程模型。Reactor是处理并发IO的一种常见模式。他主要是通过将所有的要处理的IO事件都注册到中心IO多路复用器上，同时主线程阻塞在多路复用器上，当有IO时间到来的时候或者准备">
<meta name="twitter:image" content="http://7xrl91.com1.z0.glb.clouddn.com/Eventloop.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Netty源码分析之NioEventLoop | 枯叶未凋零 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">枯叶未凋零</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">高山仰止，景行行止，虽不能至，心向往之</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Netty源码分析之NioEventLoop
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-30T10:19:14+08:00" content="2016-04-30">
              2016-04-30
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/04/30/Netty源码分析之NioEventLoop/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/04/30/Netty源码分析之NioEventLoop/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Netty源码分析之Eventloop"><a href="#Netty源码分析之Eventloop" class="headerlink" title="Netty源码分析之Eventloop"></a>Netty源码分析之Eventloop</h1><hr>
<h2 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h2><p>Netty的线程模型可以根据不同的用户参数来选择不同的线程模型，Netty支持的线程模型有Reactor单线程模型、Reactor多线程模型和主从Reactor多线程模型。<br>Reactor是处理并发IO的一种常见模式。他主要是通过将所有的要处理的IO事件都注册到中心IO多路复用器上，同时主线程阻塞在多路复用器上，当有IO时间到来的时候或者准备就绪，多路复用器就会返回同时将IO事件分派到对应的事件处理器中进行处理。</p>
<ul>
<li>Resources 事件源，系统在指定的句柄(linux是指文件描述符，Windows则是指Socket或者handle)上注册关心的事件。</li>
<li>Synchronous Event Demultiplexer 负责等待Resources的读写操作准备就绪，在非阻塞的情况下将就绪事件发送给Dispatcher。</li>
<li>Dispatcher 将Synchronous Event Demultiplexer传递过来的就绪事件分发给对应的Handler处理</li>
<li>Request Handler 应用程序定义的一组接口，当对应事件发生的时候进行调用，执行对应的事件处理。</li>
</ul>
<h3 id="Reactor单线程模型"><a href="#Reactor单线程模型" class="headerlink" title="Reactor单线程模型"></a><strong>Reactor单线程模型</strong></h3><p>Reactor单线程模型是指所有的IO操作都在同一个Nio线程上面完成。由于Reactor模型是使用异步非阻塞IO，所有的IO操作都不会导致阻塞，一个线程可以独立负责处理所有的IO操作。但是对于一些高并发的系统可能会负载过重，处理速度过慢，性能下降，导致系统出现瓶颈。</p>
<h3 id="Reactor多线程模型"><a href="#Reactor多线程模型" class="headerlink" title="Reactor多线程模型"></a><strong>Reactor多线程模型</strong></h3><p>Reactor多线程模型是在单线程模型的基础上，使用Nio线程池来处理IO操作，使用一个专门的Nio线程来监听服务端，接收客户端的TCP连接请求。至于网络IO操作，则是通过Nio线程池来负责，线程池中包含一个任务队列和N个可用的线程，负责对信息的编码、解码、读取跟发送。</p>
<h3 id="主从Reactor多线程模型"><a href="#主从Reactor多线程模型" class="headerlink" title="主从Reactor多线程模型"></a><strong>主从Reactor多线程模型</strong></h3><p>主从Reactor多线程模型主要是由一个独立的Acceptor线程负责来处理接收客户端连接。当Acceptor接收到客户端Tcp连接请求并处理完成之后，会将新创建的SocketChannel注册到IO线程池的某个Nio线程上，由它来负责对SocketChannel的读写、编码解码操作。Acceptor线程主要是负责客户端的登陆、握手及安全验证。一旦连接成功，就会将链路注册到Nio线程池中的IO线程上，由IO线程负责相应的IO操作。</p>
<h2 id="Netty-Eventloop源码分析"><a href="#Netty-Eventloop源码分析" class="headerlink" title="Netty Eventloop源码分析"></a>Netty Eventloop源码分析</h2><p><img src="http://7xrl91.com1.z0.glb.clouddn.com/Eventloop.png" alt="Eventloop"></p>
<h3 id="EventExecutorGroup"><a href="#EventExecutorGroup" class="headerlink" title="EventExecutorGroup"></a><strong>EventExecutorGroup</strong></h3><p>EventExecutorGroup实现了ScheduledExecutorService接口，表明EventExecutorGroup是JDK Executor类，提供了对定时任务的支持。EventExecutorGroup可以通过next方法来提供EventExecutor，除此之外，还提供了优雅关闭的方法shutdownGracefully()和管理EventExecutor的生命周期方法。</p>
<ul>
<li><p>优雅关闭<br>EventExecutorGroup覆盖了在Executor中的shutdown和shutdownNow方法，并添加了@Deprecated注解，要求使用者不要再去使用，同时还提供了shutdownGracefully方法进行优雅关闭和isShuttingDown方法来判断是否关闭。shutdownGracefully方法会发送给Signals给Executor，告诉Executor开始关闭，一旦调用了shutdownGradefully方法，isShuttingDown就会返回true,优雅关闭它要保证在关闭之前的静默时间内没有任务提交，一旦在静默时间内有任务提交，静默时间又会从零开始计算和任务会被接受。shutdownGracefully返回Future，当这个EventExecutorGroup管理的所有EventExecutor都被终止的时候，可以得到通知。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; shutdownGracefully(<span class="keyword">long</span> quietPeriod, <span class="keyword">long</span> timeout, TimeUnit unit);</span><br><span class="line">Future&lt;?&gt; terminationFuture();</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShuttingDown</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EventExecutor管理<br>next方法会返回EventExecutorGroup管理的一个EventExecutor和child方法会返回EventExecutorGroup管理的所有EventExecutor不可变集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&lt;E extends EventExecutor&gt; <span class="function">Set&lt;E&gt; <span class="title">children</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="EventExecutor"><a href="#EventExecutor" class="headerlink" title="EventExecutor"></a><strong>EventExecutor</strong></h3><p>EventExecutor是一个特殊的EventExecutorGroup，主要是为在事件轮询中提供一些执行Thread操作的便利方法。<br>由于EventExecutorGroup和EventExecutor是聚合关系，所有EventExecutor的next和child方法被重载为返回自身引用或者包含自身引用的不可修改集合，同时增加了parent方法返回当前EventExecutor对应的EventExecutorGroup应用。inEventLoop方法用来查询给定的线程是否在EventExecutor管理的线程当中，还提供创建Promise和Future的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;V&gt; <span class="function">Promise&lt;V&gt; <span class="title">newPromise</span><span class="params">()</span></span>;</span><br><span class="line">&lt;V&gt; <span class="function">ProgressivePromise&lt;V&gt; <span class="title">newProgressivePromise</span><span class="params">()</span></span>;</span><br><span class="line">&lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newSucceededFuture</span><span class="params">(V result)</span></span>;</span><br><span class="line">&lt;V&gt; <span class="function">Future&lt;V&gt; <span class="title">newFailedFuture</span><span class="params">(Throwable cause)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="EventloopGroup"><a href="#EventloopGroup" class="headerlink" title="EventloopGroup"></a><strong>EventloopGroup</strong></h3><p>EventloopGroup也是一种特殊的EventExecutorGroup，它允许在event loop中注册channel通道。next方法被重载为返回下一次使用的EventLoop，还新增了register方法来注册channel。register方法会返回ChannelFuture，当注册channel完成之后，channelFuture会被通知，如果是ChannelFuture register(Channel channel, ChannelPromise promise)方法的话，返回的channelFuture就是传入ChannelPromise，只有ChannelPromise成功之后，才能安全地提交任务到EventLoop中，否则任务可能会被拒绝。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoop <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span></span>;</span><br><span class="line"><span class="function">ChannelFuture <span class="title">register</span><span class="params">(Channel channel, ChannelPromise promise)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a><strong>EventLoop</strong></h3><p>EventLoop主要是用来处理在channel中注册的IO操作，一个EventLoop实例往往用来处理多个channel。parent方法会返回对应的EventLoopGroup，asInvoker方法会返回一个新创建的ChannelHandlerInvoker实例，来调用事件处理方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">EventLoopGroup <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ChannelHandlerInvoker <span class="title">asInvoker</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a><strong>NioEventLoop</strong></h3><p>NioEventLoop是SingleThreadEventLoop的具体实现，它除了负责IO操作的读写之外，还管理系统任务和定时任务的提交与执行，而且NioEventLoop使用单线程来管理Nio任务的。NioEventLoop的继承关系比较深，接下来我们从上到下进行分析</p>
<h4 id="JDK-Executor"><a href="#JDK-Executor" class="headerlink" title="JDK Executor"></a><strong>JDK Executor</strong></h4><h5 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a><strong>Executor</strong></h5><p>Executor只提供了execute方法。用户只需要传入要执行的任务，不需要关注任务的执行方式，具体的实现由子类来完成。实现了执行任务与任务方法的隔离和解耦。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a><strong>ExecutorService</strong></h5><p>ExecutorService在Executor的基础上进行了扩展，新增了关闭的相关方法、提交任务方法submit、执行任务invokeAll、invokeAny的方法。任务用Runnable和Callable来表示，Callable与Runnable的不同之处就是Callable的call方法允许返回结果和容许定义抛出受检异常。<br>ExecutorService的submit方法都支持返回结果，通过Future实现异步不阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit) <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="line"><span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a><strong>AbstractExecutorService</strong></h5><p>AbstractExecutorService提供了ExecutorService执行方法的默认实现，通过newTaskFor方法返回的RunnableFuture实现submit、invokeAny、invokeAll方法，FutureTask是RunnableFuture的默认实现。</p>
<ul>
<li><p><strong>submit</strong><br>通过newTaskFor方法将Callable类型的task包装为RunnableFuture，调用ExecutorService的execute方法执行任务，返回任务执行的任务。submit方法通过将Callable包装为RunnableFuture，将submit(callable)方法代理给execute(Runnable)执行，同时还提供了Future来返回结果。newTaskFor方法是protected的，具体的实现子类可以对方法进行重写来返回其他RunnableFuture实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>invokeAny</strong><br>invokeAny方法是通过调用doInvokeAny来实现的。<br>首先对传入的tasks集合进行检查，检查成功之后，在开始mainloop之间，会先向线程池提交一个任务，因为如果我们的线程池只有一个线程的话，线程池中的任务是串行执行的，没有并发能力，那么在调用doInvokeAny方法的时候，只要有一个任务能够正常执行完成(没有抛出异常)，方法就会返回任务的结果。<br>finally块表示只要有一个任务正常执行完成，就会对其他还没有执行完成的任务调用Future.cancell进行取消。<br>在main loop中，声明了ntask和active变量，ntask表示还有多少个任务没有提交，active表示已经提交到线程池但还没有执行完成的任务的数目。<br>既当ntask等于0时，表明所有的任务已经提交到线程池中，active等于0表明所有的任务已经完成。<br>当向线程池提交一个任务的时候，ntask–,active++,当有任务执行完成的时候(正常完成或者异常退出)，active–。<br>当调用ExecutorCompletionService的poll，返回执行结果。当执行结果为null，说明当前还没有任务执行完成，如果ntask大于0的话，就将当前任务提交到线程池中，++active；如果active等于0的话，就会退出循环，表示所有的任务都是异常结束的，抛出ExecutionException异常；<br>如果所有的任务都提交到线程池，而且还没有任务没有执行完成的话，就判断是否设置了超时时间，如果设置了超时时间，调用ExecutorCompletionService.poll()方法，如果返回的值为null的话，说明在超时时间内没有任务执行完成，抛出TimeoutException异常；<br>否则的话说明有任务已经执行完成，设置超时时间为截止时间减去当前的时间；否则调用ExecutorCompletionService.take方法。如果future的值不为空的话，说明已经有任务执行完成，–active，然后调用future.get方法获取执行结果进行返回，<br>如果期间抛出ExecutionException或者RuntimeException异常，说明任务是异常结束的，需要继续for循环执行，查看其他任务是否执行完成；<br>如果抛出的InterruptedException异常，说明任务执行过程中，当前线程被中断；如果没有抛出异常的话，说明任务正常执行完成，会进行finally块，对其他还没有执行完成的任务进行取消，最后返回结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                       <span class="keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                          <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs = <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line">        futures.add(ecs.submit(it.next()));</span><br><span class="line">        --ntasks;</span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>invokeAll不限时版本</strong><br>invokeAll方法中使用for循环对主线程进行阻塞，直到所有的任务都执行完成。它通过调用future.isDone进行判断，如果返回false的话，说明任务还没有执行完成，调用get方法进行阻塞。方法还声明了done来判断任务是否已经全部执行完成，当主线程被中断的时候来响应中断，将任务进行取消。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">        <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">                RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">                futures.add(f);</span><br><span class="line">                execute(f);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">                Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        f.get();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            done = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> futures;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                    futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>invokeAll限时版本</strong><br>限时版本在不限时版本的基础上添加了超时的判断，主要是2处if(nanos &lt; 0L)的判断。<br>第一个判断是在向线程池提交任务的时候进行判断，如果达到用户设置的超时时间，就立即返回futures。<br>第二个判断是在for循环判断任务是否已经执行完成的时候，如果任务已经完成，不会进行超时判断，如果没有完成的话，就会进行超时判断，如果超时的话，方法会立即返回。同时要对超时时间进行更新。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AbstractEventExecutor"><a href="#AbstractEventExecutor" class="headerlink" title="AbstractEventExecutor"></a><strong>AbstractEventExecutor</strong></h3><p>AbstractEventExecutor继承了AbstractExecutorService类和实现了EventExecutor接口，是EventExecutor的实现基类。<br>AbstractEventExecutor对EventExecutor的方法进行了基础实现，主要是对submit方法进行覆盖，将返回的Future的覆盖为io.netty.util.concurrent.Future和将schedule相关的方法设为不可用，抛出UnsupportedOperationException异常。<br>同时把newTaskFor方法返回的RunnableFuture实现改为PromiseTask。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PromiseTask&lt;T&gt;(<span class="keyword">this</span>, callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="AbstractScheduledEventExecutor"><a href="#AbstractScheduledEventExecutor" class="headerlink" title="AbstractScheduledEventExecutor"></a><strong>AbstractScheduledEventExecutor</strong></h3><p>AbstractScheduledEventExecutor继承了AbstractEventExecutor类，新增了对定时任务的支持。内部聚合了一个Queue来保持对定时任务的持有。</p>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a><strong>ScheduledFutureTask</strong></h4><p>ScheduledFutureTask继承PromiseTask类和实现ScheduledFuture。ScheduledFutureTask其实是java.util.concurrent.ScheduledFuture的子类，最重要的方法是getDelay方法来获取任务离执行时间的延迟值。</p>
<ul>
<li><p><strong>getDelay方法</strong><br>getDelay通过调用delayNanos方法获取时间结果，然后转化为对应的时间单位返回。delayNanos则是通过计算deadlineNanos与nanoTime的差值与0进行最大值比较，deadlineNanos是任务要执行的时间点，nanoTime则是当前的时间点，二者的差值就是delay值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> unit.convert(delayNanos(), TimeUnit.NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">delayNanos</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Math.max(<span class="number">0</span>, deadlineNanos() - nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nanoTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> System.nanoTime() - START_TIME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>run方法</strong><br>主要调用task.call执行任务，在执行任务需要设置不能cancelled标志，在任务执行完成之后设置成功标志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">assert</span> <span class="title">executor</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (periodNanos == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (setUncancellableInternal()) &#123;</span><br><span class="line">					V result = task.call();</span><br><span class="line">					setSuccessInternal(result);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">					task.call();</span><br><span class="line">					<span class="keyword">if</span> (!executor().isShutdown()) &#123;</span><br><span class="line">						<span class="keyword">long</span> p = periodNanos;</span><br><span class="line">						<span class="keyword">if</span> (p &gt; <span class="number">0</span>) &#123;</span><br><span class="line">							deadlineNanos += p;</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							deadlineNanos = nanoTime() - p;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (!isCancelled()) &#123;</span><br><span class="line">							Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = ((AbstractScheduledEventExecutor) executor()).scheduledTaskQueue;</span><br><span class="line">							<span class="keyword">assert</span> scheduledTaskQueue != <span class="keyword">null</span>;</span><br><span class="line">							scheduledTaskQueue.add(<span class="keyword">this</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">			setFailureInternal(cause);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="ScheduledFutureTask管理"><a href="#ScheduledFutureTask管理" class="headerlink" title="ScheduledFutureTask管理"></a>ScheduledFutureTask管理</h4><ul>
<li><p><strong>添加定时任务</strong><br>定时任务的添加，首先根据传入的参数创建ScheduledFutureTask对象，然后调用schedule(final ScheduledFutureTask<v> task)方法进行添加，在schedule方法中会调用inEventLoop方法判断当前线程是不是工作线程，如果是的话，直接添加任务到队列中，否则的话创建一个OneTimeTask任务，进行execute调用，在OneTimeTask任务的run方法进行添加任务入队列，在event loop中的工作线程会执行这个OneTimeTask的。</v></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit) &#123;</span><br><span class="line">    ObjectUtil.checkNotNull(command, <span class="string">"command"</span>);</span><br><span class="line">    ObjectUtil.checkNotNull(unit, <span class="string">"unit"</span>);</span><br><span class="line">    <span class="keyword">if</span> (initialDelay &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"initialDelay: %d (expected: &gt;= 0)"</span>, initialDelay));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                String.format(<span class="string">"delay: %d (expected: &gt; 0)"</span>, delay));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> schedule(<span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(</span><br><span class="line">            <span class="keyword">this</span>, Executors.&lt;Void&gt;callable(command, <span class="keyword">null</span>),</span><br><span class="line">            ScheduledFutureTask.deadlineNanos(unit.toNanos(initialDelay)), -unit.toNanos(delay)));</span><br><span class="line">&#125;</span><br><span class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> ScheduledFutureTask&lt;V&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop()) &#123;</span><br><span class="line">        scheduledTaskQueue().add(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execute(<span class="keyword">new</span> OneTimeTask() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                scheduledTaskQueue().add(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取定时任务</strong><br>pollScheduledTask方法首先对任务队列进行检验是否的为空，如果为空，直接返回null；如果任务队列不为空的话，对任务队列的头元素进行判断，如果任务队列的头元素不为空且任务满足deadline时间，将任务从任务队列中删除，返回对应的任务；否则的话，都返回null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title">pollScheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pollScheduledTask(nanoTime());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Runnable <span class="title">pollScheduledTask</span><span class="params">(<span class="keyword">long</span> nanoTime)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Queue&lt;ScheduledFutureTask&lt;?&gt;&gt; scheduledTaskQueue = <span class="keyword">this</span>.scheduledTaskQueue;</span><br><span class="line">    ScheduledFutureTask&lt;?&gt; scheduledTask = scheduledTaskQueue == <span class="keyword">null</span> ? <span class="keyword">null</span> : scheduledTaskQueue.peek();</span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (scheduledTask.deadlineNanos() &lt;= nanoTime) &#123;</span><br><span class="line">        scheduledTaskQueue.remove();</span><br><span class="line">        <span class="keyword">return</span> scheduledTask;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="SingleThreadEventExecutor"><a href="#SingleThreadEventExecutor" class="headerlink" title="SingleThreadEventExecutor"></a><strong>SingleThreadEventExecutor</strong></h3><p>SingleThreadEventExecutor是AbstractScheduledEventExecutor的子类，使用单线程来对任务进行处理，避免对共享资源的访问冲突，内部聚合了两个任务队列，一个是从AbstractScheduledEventExecutor继承得来的定时任务队列scheduledTaskQueue，一个是自身实现的可执行的任务队列taskQueue。<br>taskQueue是SingleThreadEventExecutor实例化的时候在构造函数调用newTaskQueue进行初始化的，默认是是LinkedBlockingQueue,不过newTaskQueue是protected方法，子类可以进行重写覆盖。<br>SingleThreadEventExecutor设定了几个状态标志位来保证任务队列在执行任务的时候保持状态的一致性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_NOT_STARTED = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_STARTED = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTTING_DOWN = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_SHUTDOWN = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_TERMINATED = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>pollTask</strong><br>从taskQueue中获取task，如果task是WAKEUP_TASK，则跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">pollTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Runnable task = taskQueue.poll();</span><br><span class="line">        <span class="keyword">if</span> (task == WAKEUP_TASK) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>takeTask</strong><br>由于任务的来源有两种：taskQueue和scheduledTaskQueue，需要分情况讨论。<br>首先对taskQueue进行校验，如果不是阻塞队列就会抛出UnsupportedOperationException异常。<br>如果校验通过就进入循环直到返回任务，首先从scheduledTaskQueue中获取任务，如果任务为null的话，<br>说明此时没有定时任务，就从taskQueue中获取任务，如果获取的任务不是WAKEUP_TASK，就返回对应任务，否则返回null;<br>如果获取的定时任务不为null,scheduledTaskQueue中有定时任务，就对scheduledTask的执行时间进行判断，<br>如果delayNanos大于0，即定时任务还没有到执行时间，就设置超时时间为delayNanos，从taskQueue中获取任务，<br>如果在指定的时间内没有获取到任务(此时线程会阻塞)，就会调用fetchFromScheduledTaskQueue方法，<br>为了防止taskQueue一直有任务执行，scheduledTask没有机会去执行，<br>会从scheduledTaskQueue获取满足条件的task添加到taskQueue当中，然后再次调用taskQueue.poll方法获取task。<br>如果task不为空就会返回task，否则进入下一次循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">takeTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!(taskQueue <span class="keyword">instanceof</span> BlockingQueue)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;Runnable&gt; taskQueue = (BlockingQueue&lt;Runnable&gt;) <span class="keyword">this</span>.taskQueue;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; scheduledTask = peekScheduledTask();</span><br><span class="line">        <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Runnable task = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task = taskQueue.take();</span><br><span class="line">                <span class="keyword">if</span> (task == WAKEUP_TASK) &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> task;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> delayNanos = scheduledTask.delayNanos();</span><br><span class="line">            Runnable task = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (delayNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task = taskQueue.poll(delayNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">                fetchFromScheduledTaskQueue();</span><br><span class="line">                task = taskQueue.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> task;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>execute</strong><br>execute方法只是将任务入任务队列，并没有执行任务。它会对当前线程进行判断，如果当前线程是工作线程，就直接将任务入队列，否则就调用startThread方法，在将任务入队列。由于SingleThreadEventExecutor是单线程工作的，如果线程还没有开始的话，就通过cas调用doStartThread启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">        addTask(task);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        addTask(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (STATE_UPDATER.get(<span class="keyword">this</span>) == ST_NOT_STARTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">            doStartThread();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                success = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> oldState = STATE_UPDATER.get(SingleThreadEventExecutor.<span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">if</span> (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(</span><br><span class="line">                            SingleThreadEventExecutor.<span class="keyword">this</span>, oldState, ST_SHUTTING_DOWN)) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (success &amp;&amp; gracefulShutdownStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Buggy "</span> + EventExecutor.class.getSimpleName() + <span class="string">" implementation; "</span> +</span><br><span class="line">                            SingleThreadEventExecutor.class.getSimpleName() + <span class="string">".confirmShutdown() must be called "</span> +</span><br><span class="line">                            <span class="string">"before run() implementation terminates."</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        cleanup();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        STATE_UPDATER.set(SingleThreadEventExecutor.<span class="keyword">this</span>, ST_TERMINATED);</span><br><span class="line">                        threadLock.release();</span><br><span class="line">                        <span class="keyword">if</span> (!taskQueue.isEmpty()) &#123;</span><br><span class="line">                            logger.warn(</span><br><span class="line">                                    <span class="string">"An event executor terminated with "</span> +</span><br><span class="line">                                            <span class="string">"non-empty task queue ("</span> + taskQueue.size() + <span class="string">')'</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Wake UP机制</strong> </p>
</li>
</ul>
<p>WAKEUP_TASK<br>定义一个特殊Runnable作为标志。在pollTask或者takeTask方法如果遇到WAKE_TASK的话，会跳过或者设置为null处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Runnable WAKEUP_TASK = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Do nothing.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>WAKEUP_TASK入队列<br>WAKEUP_TASK任务只有调用wakeup方法才会被入队列，同时还需要检验，只有是外部线程调用或者event loop线程状态为ST_SHUTTING_DOWN，即Executor正在关闭中，WAKEUP_TASK任务才会被添加。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop || STATE_UPDATER.get(<span class="keyword">this</span>) == ST_SHUTTING_DOWN) &#123;</span><br><span class="line">        taskQueue.add(WAKEUP_TASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>wakeup方法调用<br>wakeup方法只有在shutdown相关方法或者execute方法中才会被调用。execute方法是在添加任务入队列之后才判断是否需要调用wakeup方法，只有addTaskWakesUp为false和wakesUpForTask返回true的时候，才会调用wakeup方法。wakesUpForTask方法默认返回true，可以在子类中被覆盖，即只要addTaskWakesUp为false就会调用wakeup方法，addTaskWakesUp是final属性，是在Executor初始化的时候进行设置的。最后也就是说只有是外部线程调用execute方法的时候才会添加WAKEUP_TASK任务作为waakeup标志。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="SingleThreadEventLoop"><a href="#SingleThreadEventLoop" class="headerlink" title="SingleThreadEventLoop"></a><strong>SingleThreadEventLoop</strong></h3><p>SingleThreadEventLoop主要是重写register方法和wakesUpForTask方法。</p>
<ul>
<li><p><strong>register</strong><br>调用unsafe作为register</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> Channel channel, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (promise == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"promise"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    channel.unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>wakesUpForTask</strong><br>SingleThreadEventLoop中新增了NonWakeupRunnable接口作为标志，然后wakesUpForTask方法被覆盖为检查task是不是NonWakeupRunnable。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NonWakeupRunnable</span> <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">wakesUpForTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !(task <span class="keyword">instanceof</span> NonWakeupRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="NioEventLoop-1"><a href="#NioEventLoop-1" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>NioEventLoop聚合了一个Selector作为多路复用器，负责处理IO读写事件。<br>Selector的初始化，是在NioEventLoop的构造函数中调用OpenSelector方法创建，同时可以通过DISABLE_KEYSET_OPTIMIZATION标志位是否对Selector的SelectionKey进行优化，标志位是通过io.netty.noKeySetOptimization进行设置。<br>如果没有开启SelectionKey优化，在创建Selector之后就直接返回了，否则的话就进行SelectionKey优化操作。<br>优化操作首先通过反射获取selectionKey和publicSelectedKeys属性，将它们的访问权限设置为true，然后使用Netty的包装类SelectedSelectionKeySet进行替换。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Selector selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        selector = provider.openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DISABLE_KEYSET_OPTIMIZATION) &#123;</span><br><span class="line">        <span class="keyword">return</span> selector;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; selectorImplClass =</span><br><span class="line">                Class.forName(<span class="string">"sun.nio.ch.SelectorImpl"</span>, <span class="keyword">false</span>, PlatformDependent.getSystemClassLoader());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure the current selector implementation is what we can instrument.</span></span><br><span class="line">        <span class="keyword">if</span> (!selectorImplClass.isAssignableFrom(selector.getClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> selector;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"selectedKeys"</span>);</span><br><span class="line">        Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">"publicSelectedKeys"</span>);</span><br><span class="line"></span><br><span class="line">        selectedKeysField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        publicSelectedKeysField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        selectedKeysField.set(selector, selectedKeySet);</span><br><span class="line">        publicSelectedKeysField.set(selector, selectedKeySet);</span><br><span class="line"></span><br><span class="line">        selectedKeys = selectedKeySet;</span><br><span class="line">        logger.trace(<span class="string">"Instrumented an optimized java.util.Set into: &#123;&#125;"</span>, selector);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        selectedKeys = <span class="keyword">null</span>;</span><br><span class="line">        logger.trace(<span class="string">"Failed to instrument an optimized java.util.Set into: &#123;&#125;"</span>, selector, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在分析完Selector之后，再来看run方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> oldWakenUp = wakenUp.getAndSet(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasTasks()) &#123;</span><br><span class="line">                selectNow();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                select(oldWakenUp);</span><br><span class="line">                <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                    selector.wakeup();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                processSelectedKeys();</span><br><span class="line">                runAllTasks();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">                processSelectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Unexpected exception in the selector loop."</span>, t);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Prevent possible consecutive immediate failures that lead to</span></span><br><span class="line">            <span class="comment">// excessive CPU consumption.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先将wakeup原来的值保存到oldWakenUp中，然后设置为false。<br>然后通过hasTasks判断任务队列中是否有任务没有处理，如果有的话就调用selectNow进行select操作，selectNow方法会调用Selector的selectNow方法，如果有准备就绪的Channel，就返回就绪的Channel集合，否则返回0，在选择操作完成之后，再次判断用户是否调用了Selector的wakeup方法，如果调用了，就调用selector的wakeup方法。<br>如果没有任务要处理的话，就执行select方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Selector.select() returned prematurely because "</span> +</span><br><span class="line">                            <span class="string">"Thread.currentThread().interrupt() was called. Use "</span> +</span><br><span class="line">                            <span class="string">"NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先获取系统当前纳秒时间，调用delayNanos获取定时任务的执行时间计算出超时时间，再给超时时间添加0.5毫秒的调整时间，然后对超时时间进行判断，如果需要立即执行或者已经超时了，然后调用selector.selectNow进行事件轮询，同时将selectCnt设置为1，然后退出循环；否则将剩余时间作为参数进行select操作，同时selectCnt加1(每完成一次select操作+1)，在select操作完成之后，对当前状态进行判断，如果selectionKey不等于0，即有Channel就绪、oldWakeUp为true、有用户调用过wakeup方法进行唤醒、有定时任务需要执行，就退出当前循环。否则的话，就是说当前的select操作是空轮询，就有可能导致java的epoll bug，导致IO状态时刻处于100%状态。<br>Netty对Bug进行了规避。它对Selector 的select操作周期进行统计，每进行一次空轮询进行一次计数，当在某周期时间内达到一定次数的时候，就认为触发BUG了，就通过重建Selector进行恢复。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rebuildSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop()) &#123;</span><br><span class="line">        execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                rebuildSelector();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Selector oldSelector = selector;</span><br><span class="line">    <span class="keyword">final</span> Selector newSelector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldSelector == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        newSelector = openSelector();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">"Failed to create a new Selector."</span>, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register all channels to the new Selector.</span></span><br><span class="line">    <span class="keyword">int</span> nChannels = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (SelectionKey key: oldSelector.keys()) &#123;</span><br><span class="line">                Object a = key.attachment();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!key.isValid() || key.channel().keyFor(newSelector) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> interestOps = key.interestOps();</span><br><span class="line">                    key.cancel();</span><br><span class="line">                    SelectionKey newKey = key.channel().register(newSelector, interestOps, a);</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                        <span class="comment">// Update SelectionKey</span></span><br><span class="line">                        ((AbstractNioChannel) a).selectionKey = newKey;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nChannels ++;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to re-register a Channel to the new Selector."</span>, e);</span><br><span class="line">                    <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                        AbstractNioChannel ch = (AbstractNioChannel) a;</span><br><span class="line">                        ch.unsafe().close(ch.unsafe().voidPromise());</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                        invokeChannelUnregistered(task, key, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ConcurrentModificationException e) &#123;</span><br><span class="line">            <span class="comment">// Probably due to concurrent modification of the key set.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    selector = newSelector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        oldSelector.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to close the old Selector."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"Migrated "</span> + nChannels + <span class="string">" channel(s) to the new Selector."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先通过inEventLoop判断是否其他线程发起的rebuildSelector操作，如果是其他线程发起的话，就将rebuildSelector封装成Task，添加到任务队列中，防止多线程并发操作共享资源。<br>首先通过oldSelector持有原来的selector，然后通过openSelector创建新的selector，然后通过循环将原来在oldSelector注册的socketChannel重新注册到新的selector上。最后将新的selector设置为selector，旧的selector关闭。</p>
<p>在select操作完成之后，如果轮询有就绪的channel，就调用processSelectedKeys执行处理。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processSelectedKeysOptimized(selectedKeys.flip());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有开启SelectionKey优化的话，就会调用processSelectedKeysPlain方法，首先对selectionKeys进行检验，然后获取selectionKeys的迭代器进行循环，通过获取SelectionKey和attachment，同时进行remove操作，将selectionKey从set中移除，防止下次被重复选择和处理。然后对attachment的类型进行判断，如果是AbstractNioChannel类型，说明是NioSocketChannel或者NioSeverSocketChannel,需要进行IO读写的相关操作。如果是NioTask，需要进行类型转换，调用processSelectedKey<br>进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysPlain</span><span class="params">(Set&lt;SelectionKey&gt; selectedKeys)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = i.next();</span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        i.remove();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">            processSelectedKey(k, task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!i.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">            selectAgain();</span><br><span class="line">            selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create the iterator again to avoid ConcurrentModificationException</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = selectedKeys.iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过channel获取unsafe,判断选择键是否合法，如果不合法就调用close方法进行资源释放。否则，就对网络操作位进行判断，如果是read或者accept操作的话，就调用unsafe.read方法，如果channel是ServerSocketChannel的话，它的read操作是接收客户端连接，如果是SocketChannel的话，就是从SocketChannel读取ByteBuffer；如果网络操作位是write的话，就说明有半包消息没有发送完成，需要调用flush方法进行发送；如果网络操作位是connect的话，则需要对调用finishConnectd对连接结果进行判断，不过在判断之前需要对网络操作位进行修改，将connect操作位进行注销。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            unsafe.read();</span><br><span class="line">            <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">                <span class="comment">// Connection already closed - no need to handle write.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在处理完成IO操作之后，就可以对定时任务或者非IO任务进行执行。它首先对定时任务进行处理，如果当前没有定时任务的话，就直接返回，否则的话就对定时任务的执行时间进行判断，如果有需要立即执行或者已经超时的，就将定时任务添加到taskQueue中，同时从定时任务中删除；否则的话就说明没有定时任务需要执行，直接退出。然后通过pollTask从taskQueue获取任务，调用task.run执行任务，直到task为null，即没有需要执行的任务才退出循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"A task raised an exception."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于NioEventLoop可以同时处理IO事件和非IO任务，可以通过IO比例ioRatio进行定制，默认为50%.同时可以设定Task的执行时间。由于获取系统时间是个耗时的操作，设定每循环60次进行判断一次，如果超过分配给非IO操作的超时时间，就会退出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">processSelectedKeys();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">runAllTasks</span><span class="params">(<span class="keyword">long</span> timeoutNanos)</span> </span>&#123;</span><br><span class="line">    fetchFromScheduledTaskQueue();</span><br><span class="line">    Runnable task = pollTask();</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</span><br><span class="line">    <span class="keyword">long</span> runTasks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> lastExecutionTime;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            task.run();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"A task raised an exception."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        runTasks ++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((runTasks &amp; <span class="number">0x3F</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (lastExecutionTime &gt;= deadline) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        task = pollTask();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastExecutionTime = ScheduledFutureTask.nanoTime();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lastExecutionTime = lastExecutionTime;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <div>
      
        
      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Netty/" rel="tag">#Netty</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/29/Spring-Aop-源码分析/" rel="next" title="Spring Aop 源码分析">
                <i class="fa fa-chevron-left"></i> Spring Aop 源码分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/01/Java-Collection-集合框架图/" rel="prev" title="Java Collection 集合框架图">
                Java Collection 集合框架图 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
  <a class="jiathis_button_tqq"></a>
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
  <a class="jiathis_button_renren"></a>
  <a class="jiathis_button_qzone"></a>
  <a class="jiathis_button_kaixin001"></a>
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/04/30/Netty源码分析之NioEventLoop/"
           data-title="Netty源码分析之NioEventLoop" data-url="http://xianyijun.github.io/2016/04/30/Netty源码分析之NioEventLoop/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="枯叶未凋零" />
          <p class="site-author-name" itemprop="name">枯叶未凋零</p>
          <p class="site-description motion-element" itemprop="description">高山仰止，景行行止，虽不能至，心向往之</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">33</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/xianyijun" target="_blank" title="github">
                  
                    <i class="fa fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/xianyijun" target="_blank" title="weibo">
                  
                    <i class="fa fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <i class="fa fa-globe fa-fw"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://jm.taobao.org/" title="阿里中间件团队博客" target="_blank">阿里中间件团队博客</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.zhangxinxu.com/" title="张鑫旭" target="_blank">张鑫旭</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://my.oschina.net/huangyong/" title="黄勇" target="_blank">黄勇</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://rednaxelafx.iteye.com/" title="RednaxelaFX" target="_blank">RednaxelaFX</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://jinnianshilongnian.iteye.com/" title="开涛" target="_blank">开涛</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://huangz.me/" title="黄健宏" target="_blank">黄健宏</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Netty源码分析之Eventloop"><span class="nav-number">1.</span> <span class="nav-text">Netty源码分析之Eventloop</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty线程模型"><span class="nav-number">1.1.</span> <span class="nav-text">Netty线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor单线程模型"><span class="nav-number">1.1.1.</span> <span class="nav-text">Reactor单线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reactor多线程模型"><span class="nav-number">1.1.2.</span> <span class="nav-text">Reactor多线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主从Reactor多线程模型"><span class="nav-number">1.1.3.</span> <span class="nav-text">主从Reactor多线程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Netty-Eventloop源码分析"><span class="nav-number">1.2.</span> <span class="nav-text">Netty Eventloop源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EventExecutorGroup"><span class="nav-number">1.2.1.</span> <span class="nav-text">EventExecutorGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventExecutor"><span class="nav-number">1.2.2.</span> <span class="nav-text">EventExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventloopGroup"><span class="nav-number">1.2.3.</span> <span class="nav-text">EventloopGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EventLoop"><span class="nav-number">1.2.4.</span> <span class="nav-text">EventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoop"><span class="nav-number">1.2.5.</span> <span class="nav-text">NioEventLoop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JDK-Executor"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">JDK Executor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Executor"><span class="nav-number">1.2.5.1.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ExecutorService"><span class="nav-number">1.2.5.1.2.</span> <span class="nav-text">ExecutorService</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AbstractExecutorService"><span class="nav-number">1.2.5.1.3.</span> <span class="nav-text">AbstractExecutorService</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractEventExecutor"><span class="nav-number">1.2.6.</span> <span class="nav-text">AbstractEventExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AbstractScheduledEventExecutor"><span class="nav-number">1.2.7.</span> <span class="nav-text">AbstractScheduledEventExecutor</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFutureTask"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">ScheduledFutureTask</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ScheduledFutureTask管理"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">ScheduledFutureTask管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadEventExecutor"><span class="nav-number">1.2.8.</span> <span class="nav-text">SingleThreadEventExecutor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SingleThreadEventLoop"><span class="nav-number">1.2.9.</span> <span class="nav-text">SingleThreadEventLoop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NioEventLoop-1"><span class="nav-number">1.2.10.</span> <span class="nav-text">NioEventLoop</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">冼毅俊</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"xianyijun"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
